<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/x-icon" href="snow-white.ico">
    <link href="style.css" rel="stylesheet" />
    <title>Ma page de test</title>
</head>

<body>
    <h1>Test Nikke Utils - Show results</h1>

    <div id="nikkes-table-container">
    </div>

    <h2>GetAllNikkes</h2>
    <pre id="data-output-all-nikkes"></pre>

    <h2>GetNikkeByName</h2>
    <pre id="data-output"></pre>

    <h2>PullTen</h2>
    <p id="gacha-output"></p>

    <h2>CheckFullBurst</h2>
    <p id="team-output"></p>

    <script type="module">

        import {
            getAllNikkes,
            getNikkeByName,
            pullTen,
            checkFullBurst
        } from '../index.js';

        let currentNikkesData = [];
        let sortColumn = 'name'; // Tri par défaut sur 'name'
        let sortDirection = 'asc';

        // Définir les colonnes à afficher (y compris les colonnes triables)
        const columns = ['id', 'name', 'rarity', 'burst', 'element', 'manufacturer', 'class', 'weapon', 'squad', 'specialties', 'treasure', 'reEnterBurstSkill', 'canChangeBurstStageThreeToOne', 'cooldown', 'dateAdded'];

        // ----------------------------------------------------
        // LOGIQUE DE TRI
        // ----------------------------------------------------

        function sortData(column, direction) {
            const sortedData = [...currentNikkesData];

            sortedData.sort((a, b) => {
                let comparison = 0;
                let aVal = a[column] || '';
                let bVal = b[column] || '';

                if (column === 'dateAdded') {
                    // 1. Traitement spécifique pour les dates
                    const aTime = new Date(aVal).getTime();
                    const bTime = new Date(bVal).getTime();

                    comparison = aTime - bTime;

                    // 2. Tri secondaire par NOM si les dates sont identiques
                    if (comparison === 0) {
                        return a.name.localeCompare(b.name);
                    }

                } else {
                    // Traitement par défaut (alphabétique pour 'name')
                    comparison = aVal.localeCompare(bVal);
                }

                return direction === 'asc' ? comparison : comparison * -1;
            });

            return sortedData;
        }

        // Fonction appelée lors du clic sur l'en-tête
        function sortNikkesTable(event) {
            const newColumn = event.currentTarget.getAttribute('data-column');

            if (newColumn === sortColumn) {
                sortDirection = (sortDirection === 'asc') ? 'desc' : 'asc';
            } else {
                sortColumn = newColumn;
                sortDirection = 'asc';
            }

            // Mettre à jour et re-dessiner le tableau
            currentNikkesData = sortData(sortColumn, sortDirection);
            renderTable(currentNikkesData, sortColumn, sortDirection);
        }
        // ----------------------------------------------------
        // LOGIQUE DE RENDU DU TABLEAU
        // ----------------------------------------------------

        function renderTable(data, sortedCol, sortedDir) {
            const container = document.getElementById('nikkes-table-container');
            container.innerHTML = ''; // Nettoyer le conteneur

            if (!data || data.length === 0) {
                container.innerHTML = '<p>Aucune donnée de Nikke trouvée.</p>';
                return;
            }

            let html = '<table class="nikkes-table"><thead><tr>';

            // Création de l'en-tête
            columns.forEach(col => {
                const headerText = col.charAt(0).toUpperCase() + col.slice(1);

                let className = '';
                if (col === sortedCol) { // Si c'est la colonne triée
                    className = `sorted-${sortedDir}`; // Applique la classe sorted-asc ou sorted-desc
                }

                // Ajout de l'attribut data-column pour le tri
                html += `<th data-column="${col}" class="${className}">${headerText}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Création des lignes du tableau (inchangé)
            data.forEach(nikke => {
                html += '<tr>';

                columns.forEach(col => {
                    let cellContent = nikke[col] || '-';
                    //console.log(cellContent)
                    if (typeof cellContent == 'object') {
                        console.log(cellContent)
                        cellContent = Object.values(cellContent).join(",<br/> ")
                    }
                    let className = '';

                    if (col === 'rarity') {
                        className = `rarity-${nikke[col]}`;
                    }

                    html += `<td class="${className}">${cellContent}</td>`;
                });

                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            // 3. Attacher les écouteurs d'événements APRÈS l'insertion du HTML
            // SÉLECTIONNE UNIQUEMENT LES COLONNES DEMANDÉES (name et dateAdded)
            const headers = container.querySelectorAll('th[data-column="name"], th[data-column="dateAdded"]');

            // Attache les événements de clic
            headers.forEach(header => {
                // Ajoute la classe cliquable pour le style (optionnel si le CSS est bien ciblé)
                header.classList.add('sortable-header');
                header.addEventListener('click', sortNikkesTable);
            });

            // Mettre à jour l'état de la console si nécessaire
            console.log(`Tableau affiché. Tri actuel: ${sortedCol} (${sortedDir})`);
        }

        // ----------------------------------------------------
        // INITIALISATION
        // ----------------------------------------------------

        // Récupérer les données initiales
        currentNikkesData = getAllNikkes();

        // Trier les données initiales
        currentNikkesData = sortData(sortColumn, sortDirection);

        // Rendre le tableau initial
        renderTable(currentNikkesData, sortColumn, sortDirection);

        // ----------------------------------------------------
        // CONSOLE LOGS (Optionnel - Pour vérifier les données)
        // ----------------------------------------------------

        const allData = getAllNikkes();
        console.log('Toutes les Nikkes:', allData);
        let allNikkes = "";
        for (let i = 0; i < allData.length; i++) {
            allNikkes += JSON.stringify(allData[i]) + "\n";
        }
        document.getElementById('data-output-all-nikkes').textContent = allNikkes;

        const rapi = getNikkeByName('Rapi');
        console.log('Rapi trouvée:', rapi);

        console.log('Liste complète des Nikkes (Taille) :', allData.length);
        console.log('Détails de Rapi (Objet) :', getNikkeByName('Rapi'));

        document.getElementById('data-output').textContent = JSON.stringify(getNikkeByName('Helm'), null, 2);

        const mesTirages = pullTen();
        console.log('Résultats Gacha (10 pull):', mesTirages);
        console.log('Nombre de SSR obtenus :', mesTirages.filter(r => r === 'SSR').length);
        document.getElementById('gacha-output').textContent = mesTirages.join(', ');

        const neon = getNikkeByName('Neon');
        const anis = getNikkeByName('Anis');
        const modernia = getNikkeByName('Modernia');

        const maTeamValide = [neon, anis, modernia, rapi];
        const teamResult = checkFullBurst(maTeamValide);
        console.log('Analyse de l\'équipe:', teamResult.message);

        const teamIncomplete = [anis, modernia, getNikkeByName('Rapi')];
        const incompleteResult = checkFullBurst(teamIncomplete);
        console.log('Analyse Équipe Valide :', teamResult.message);
        // 'Full Burst Ready!'
        console.log('Analyse Équipe Incomplète :', incompleteResult.message);
        //'Impossible de Full Burst. Manquant : Burst I'

        document.getElementById('team-output').textContent = `Valide: ${teamResult.message} | Invalide: ${incompleteResult.message}`;

    </script>
</body>

</html>